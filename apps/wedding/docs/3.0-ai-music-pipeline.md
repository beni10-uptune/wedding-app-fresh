# Uptune 3.0: AI Music Intelligence Pipeline

## Executive Summary

This document outlines the complete AI-powered music recommendation system for Uptune 3.0, combining:
- Multi-model AI orchestration (Claude, GPT, Gemini, Spotify)
- Comprehensive music database built on Spotify's API
- Real-time personalization engine
- Intelligent playlist generation with DJ-ready outputs

**Goal**: Create the world's most intelligent wedding playlist generator that delivers professional, culturally-aware, perfectly-mixed playlists in seconds.

## Architecture Overview

```
User Input â†’ Context Enrichment â†’ Musical Analysis â†’ AI Generation â†’ Database Matching â†’ Quality Assurance â†’ Final Playlist
            (Gemini + Google)     (Spotify AI)       (Claude Opus)    (Vector Search)     (Multi-Model)      (DJ-Ready)
```

## Part 1: The Music Database Foundation

### Core Database Schema

```typescript
// Primary song entity with all Spotify + enriched data
interface WeddingSong {
  // Spotify Core Data (Source of Truth)
  spotify_id: string;              // Primary key - universal identifier
  title: string;
  artist: string;
  album: string;
  duration_ms: number;
  preview_url: string;             // 30-second preview
  explicit: boolean;               // Content safety flag
  popularity: number;              // 0-100, updated weekly
  
  // Spotify Audio Features (The Magic)
  tempo: number;                   // BPM - critical for mixing
  key: number;                     // 0-11 (C, C#, D, etc.)
  mode: number;                    // 0=minor, 1=major
  time_signature: number;          // 4/4, 3/4, etc.
  energy: number;                  // 0-1 (intensity)
  danceability: number;            // 0-1 (how suitable for dancing)
  valence: number;                 // 0-1 (musical positivity/happiness)
  acousticness: number;            // 0-1 (acoustic vs. electronic)
  instrumentalness: number;        // 0-1 (no vocals vs. vocals)
  speechiness: number;             // 0-1 (spoken word detection)
  liveness: number;                // 0-1 (audience presence)
  loudness: number;                // Average decibels
  
  // Wedding-Specific Classification
  wedding_moments: WeddingMoment[];
  wedding_genres: string[];
  wedding_moods: string[];
  cultural_fit: string[];          // ["western", "indian", "latin", etc.]
  age_appeal: string[];            // ["gen-z", "millennial", "gen-x", "boomer"]
  
  // DJ Information
  intro_beats: number;             // Beats before vocals start
  outro_beats: number;             // Beats after vocals end
  mix_in_point: number;            // Optimal mix-in timestamp
  mix_out_point: number;           // Optimal mix-out timestamp
  harmonic_keys: string[];         // Compatible keys for mixing (Camelot wheel)
  bpm_range: [number, number];     // Â±7% for beatmatching
  
  // AI-Enhanced Metadata
  emotional_arc: 'building' | 'steady' | 'peak' | 'cooling';
  lyrical_themes: string[];        // AI-analyzed themes
  inappropriate_flags: string[];   // Reasons why it might not work
  ai_confidence: number;           // How sure we are about classification
  
  // Usage Analytics
  wedding_play_count: number;      // Times used in our app
  success_rate: number;            // % of times kept in final playlist
  dj_rating: number;               // Professional DJ ratings
  user_ratings: number[];          // Crowd feedback
  
  // Caching & Updates
  last_updated: Date;
  last_popularity_check: Date;
  last_ai_analysis: Date;
  data_version: string;
}

// Wedding moment taxonomy
enum WeddingMoment {
  PRELUDE = 'prelude',                    // Guest arrival
  PROCESSIONAL = 'processional',          // Walking down aisle
  RECESSIONAL = 'recessional',            // Exit ceremony
  COCKTAIL = 'cocktail',                  // Cocktail hour
  ENTRANCE = 'entrance',                  // Grand entrance
  DINNER = 'dinner',                      // Dinner service
  FIRST_DANCE = 'first_dance',            // Couple's first dance
  PARENT_DANCE = 'parent_dance',          // Father-daughter/Mother-son
  PARTY_WARMUP = 'party_warmup',          // Getting people dancing
  PARTY_PEAK = 'party_peak',              // Peak energy
  PARTY_CLASSIC = 'party_classic',        // Crowd pleasers
  SLOW_DANCE = 'slow_dance',              // Romantic moments
  CULTURAL = 'cultural',                  // Cultural specific
  LAST_DANCE = 'last_dance',              // Final song
  AFTER_PARTY = 'after_party'             // Late night
}
```

### Spotify Data Import Pipeline

```typescript
class SpotifyDatabaseBuilder {
  private spotify: SpotifyWebApi;
  private db: PrismaClient;
  private rateLimiter: RateLimiter;
  
  constructor() {
    this.rateLimiter = new RateLimiter({
      requestsPerSecond: 3,  // Stay under Spotify's limits
      burst: 10
    });
  }
  
  async buildComprehensiveDatabase() {
    console.log('ðŸŽµ Starting Spotify wedding music import...');
    
    // Phase 1: Harvest from curated playlists
    const weddingMusic = await this.harvestWeddingPlaylists();
    
    // Phase 2: Enrich with audio features
    const enrichedMusic = await this.enrichWithAudioFeatures(weddingMusic);
    
    // Phase 3: Classify for wedding moments
    const classifiedMusic = await this.classifyForWeddings(enrichedMusic);
    
    // Phase 4: Build mixing relationships
    const djReadyMusic = await this.addDJMetadata(classifiedMusic);
    
    return djReadyMusic;
  }
  
  async harvestWeddingPlaylists(): Promise<Map<string, SpotifyTrack>> {
    const tracks = new Map();
    
    // Target search terms for comprehensive coverage
    const searchTerms = [
      // General wedding
      'wedding', 'wedding 2025', 'wedding 2024', 'wedding reception',
      
      // Specific moments
      'first dance', 'father daughter dance', 'mother son dance',
      'wedding processional', 'wedding recessional', 'wedding entrance',
      'wedding dinner', 'wedding cocktail hour', 'wedding party',
      
      // Genres
      'wedding country', 'wedding rock', 'wedding pop', 'wedding r&b',
      'wedding hip hop', 'wedding classical', 'wedding jazz',
      
      // Cultural
      'indian wedding', 'jewish wedding', 'latin wedding', 'african wedding',
      
      // Moods
      'romantic songs', 'love songs', 'celebration songs', 'party classics'
    ];
    
    for (const term of searchTerms) {
      await this.rateLimiter.throttle();
      
      const playlists = await this.spotify.searchPlaylists(term, { 
        limit: 50,
        market: 'US'
      });
      
      for (const playlist of playlists.body.playlists.items) {
        // Only use playlists with significant followers (quality signal)
        if (playlist.followers?.total > 100) {
          const playlistTracks = await this.getAllPlaylistTracks(playlist.id);
          
          for (const item of playlistTracks) {
            if (item.track && !tracks.has(item.track.id)) {
              tracks.set(item.track.id, {
                ...item.track,
                found_in_playlists: [playlist.name],
                playlist_contexts: [term]
              });
            }
          }
        }
      }
    }
    
    console.log(`âœ… Harvested ${tracks.size} unique wedding-relevant tracks`);
    return tracks;
  }
  
  async enrichWithAudioFeatures(tracks: Map<string, SpotifyTrack>) {
    const enriched = [];
    const trackIds = Array.from(tracks.keys());
    
    // Process in batches of 50 (Spotify's limit)
    for (const batch of chunk(trackIds, 50)) {
      await this.rateLimiter.throttle();
      
      const audioFeatures = await this.spotify.getAudioFeatures(batch);
      
      for (const features of audioFeatures.body.audio_features) {
        if (features) {
          const track = tracks.get(features.id);
          
          enriched.push({
            // Core identification
            spotify_id: features.id,
            title: track.name,
            artist: track.artists.map(a => a.name).join(', '),
            album: track.album.name,
            
            // Basic metadata
            duration_ms: track.duration_ms,
            explicit: track.explicit,
            popularity: track.popularity,
            preview_url: track.preview_url,
            
            // Audio features (all of them!)
            tempo: features.tempo,
            key: features.key,
            mode: features.mode,
            time_signature: features.time_signature,
            energy: features.energy,
            danceability: features.danceability,
            valence: features.valence,
            acousticness: features.acousticness,
            instrumentalness: features.instrumentalness,
            speechiness: features.speechiness,
            liveness: features.liveness,
            loudness: features.loudness,
            
            // Context from discovery
            found_in_playlists: track.found_in_playlists,
            playlist_contexts: track.playlist_contexts
          });
        }
      }
    }
    
    return enriched;
  }
  
  async classifyForWeddings(songs: EnrichedSong[]) {
    return songs.map(song => ({
      ...song,
      
      // Classify wedding moments based on audio features
      wedding_moments: this.inferWeddingMoments(song),
      
      // Determine mixing compatibility
      harmonic_keys: this.getHarmonicKeys(song.key, song.mode),
      bpm_range: [song.tempo * 0.93, song.tempo * 1.07], // Â±7% for beatmatching
      
      // Flag potential issues
      inappropriate_flags: this.checkAppropriateness(song),
      
      // Energy classification
      emotional_arc: this.classifyEmotionalArc(song),
      
      // Age appeal based on release date and style
      age_appeal: this.inferAgeAppeal(song)
    }));
  }
  
  private inferWeddingMoments(song: EnrichedSong): WeddingMoment[] {
    const moments: WeddingMoment[] = [];
    
    // Processional: Classical, slow, emotional
    if (song.tempo < 80 && song.energy < 0.4 && song.valence > 0.5) {
      moments.push(WeddingMoment.PROCESSIONAL);
    }
    
    // First Dance: Romantic, moderate tempo, high valence
    if (song.tempo >= 60 && song.tempo <= 100 && 
        song.energy < 0.6 && song.valence > 0.6 &&
        song.acousticness > 0.3) {
      moments.push(WeddingMoment.FIRST_DANCE);
    }
    
    // Dinner: Low energy, any tempo, not too loud
    if (song.energy < 0.5 && song.loudness > -20 && 
        song.speechiness < 0.1) {
      moments.push(WeddingMoment.DINNER);
    }
    
    // Party Peak: High energy, danceable, fast
    if (song.energy > 0.7 && song.danceability > 0.7 && 
        song.tempo > 110 && song.valence > 0.6) {
      moments.push(WeddingMoment.PARTY_PEAK);
    }
    
    // Cocktail Hour: Medium energy, sophisticated
    if (song.energy >= 0.3 && song.energy <= 0.6 &&
        song.valence > 0.5 && song.danceability < 0.7) {
      moments.push(WeddingMoment.COCKTAIL);
    }
    
    return moments;
  }
  
  private getHarmonicKeys(key: number, mode: number): string[] {
    // Camelot Wheel for harmonic mixing
    const camelotWheel = {
      // Major keys (B)
      '1B': { key: 6, mode: 1 },   // B Major / Ab Major
      '2B': { key: 1, mode: 1 },   // F# Major / Gb Major
      '3B': { key: 8, mode: 1 },   // C# Major / Db Major
      '4B': { key: 3, mode: 1 },   // Ab Major / G# Major
      '5B': { key: 10, mode: 1 },  // Eb Major / D# Major
      '6B': { key: 5, mode: 1 },   // Bb Major / A# Major
      '7B': { key: 0, mode: 1 },   // F Major
      '8B': { key: 7, mode: 1 },   // C Major
      '9B': { key: 2, mode: 1 },   // G Major
      '10B': { key: 9, mode: 1 },  // D Major
      '11B': { key: 4, mode: 1 },  // A Major
      '12B': { key: 11, mode: 1 }, // E Major
      
      // Minor keys (A)
      '1A': { key: 3, mode: 0 },   // Ab minor / G# minor
      '2A': { key: 10, mode: 0 },  // Eb minor / D# minor
      '3A': { key: 5, mode: 0 },   // Bb minor / A# minor
      '4A': { key: 0, mode: 0 },   // F minor
      '5A': { key: 7, mode: 0 },   // C minor
      '6A': { key: 2, mode: 0 },   // G minor
      '7A': { key: 9, mode: 0 },   // D minor
      '8A': { key: 4, mode: 0 },   // A minor
      '9A': { key: 11, mode: 0 },  // E minor
      '10A': { key: 6, mode: 0 },  // B minor
      '11A': { key: 1, mode: 0 },  // F# minor / Gb minor
      '12A': { key: 8, mode: 0 }   // C# minor / Db minor
    };
    
    // Find current position
    let currentCamelot = '';
    for (const [camelot, spec] of Object.entries(camelotWheel)) {
      if (spec.key === key && spec.mode === mode) {
        currentCamelot = camelot;
        break;
      }
    }
    
    // Get compatible keys (adjacent on wheel)
    const compatible = [];
    const number = parseInt(currentCamelot);
    const letter = currentCamelot.slice(-1);
    
    // Same number, different letter (relative major/minor)
    compatible.push(`${number}${letter === 'A' ? 'B' : 'A'}`);
    
    // Adjacent numbers, same letter
    const prevNum = number === 1 ? 12 : number - 1;
    const nextNum = number === 12 ? 1 : number + 1;
    compatible.push(`${prevNum}${letter}`);
    compatible.push(`${nextNum}${letter}`);
    
    return compatible;
  }
}
```

## Part 2: AI Orchestration Pipeline

### Multi-Model Architecture

```typescript
class AIOrchestrationEngine {
  private models: {
    gemini: GoogleGenerativeAI;      // Context enrichment
    claude: Anthropic;               // Creative generation
    gpt: OpenAI;                     // Technical optimization
    spotify: SpotifyAI;              // Musical analysis
    perplexity: PerplexityAI;        // Current trends
  };
  
  async generatePerfectPlaylist(input: UserInput): Promise<WeddingPlaylist> {
    // Step 1: Context Enrichment (Gemini + Google Knowledge)
    const enrichedContext = await this.enrichContext(input);
    
    // Step 2: Musical DNA Analysis (Spotify)
    const musicalDNA = await this.analyzeMusicalDNA(enrichedContext);
    
    // Step 3: Creative Generation (Claude Opus)
    const creativePlaylist = await this.generateCreative(enrichedContext, musicalDNA);
    
    // Step 4: Database Matching (Vector Search)
    const matchedPlaylist = await this.matchToRealSongs(creativePlaylist);
    
    // Step 5: Technical Optimization (GPT-5)
    const optimizedPlaylist = await this.optimizeFlow(matchedPlaylist);
    
    // Step 6: Quality Assurance (Multi-Model Consensus)
    const finalPlaylist = await this.qualityAssurance(optimizedPlaylist);
    
    return finalPlaylist;
  }
}
```

### Step 1: Context Enrichment (Gemini)

```typescript
class ContextEnrichmentEngine {
  private gemini: GoogleGenerativeAI;
  
  async enrichContext(input: UserInput): Promise<EnrichedContext> {
    const response = await this.gemini.generateContent({
      model: 'gemini-2.0-flash-exp',
      systemInstruction: `You are a wedding context analyst. 
        Enrich the user's input with cultural insights, regional preferences,
        and demographic understanding.`,
      
      contents: [{
        role: 'user',
        parts: [{
          text: `Analyze this wedding context:
            Location: ${input.country}
            Genres: ${input.genres}
            Wedding Type: ${input.weddingType}
            Special Requirements: ${input.customInstructions}
            
            Provide:
            1. Cultural traditions that affect music
            2. Regional music preferences
            3. Demographic insights
            4. Potential sensitivities
            5. Celebration style expectations`
        }]
      }],
      
      // Use Google's knowledge graph
      groundingConfig: {
        sources: ['google_knowledge_graph']
      }
    });
    
    return {
      original: input,
      cultural: response.cultural_insights,
      regional: response.regional_preferences,
      demographics: response.demographic_analysis,
      sensitivities: response.potential_issues
    };
  }
}
```

### Step 2: Musical DNA Analysis (Spotify)

```typescript
class MusicalDNAAnalyzer {
  private spotify: SpotifyWebApi;
  
  async analyzeMusicalDNA(context: EnrichedContext): Promise<MusicalDNA> {
    // If user provided Spotify playlists
    if (context.original.spotifyPlaylists?.length) {
      const playlists = await Promise.all(
        context.original.spotifyPlaylists.map(url => 
          this.analyzePlaylist(this.extractPlaylistId(url))
        )
      );
      
      // Extract patterns
      const audioProfile = this.aggregateAudioFeatures(playlists);
      const genreWeights = this.calculateGenreWeights(playlists);
      const artistAffinities = this.extractTopArtists(playlists);
      
      return {
        audioProfile,
        genreWeights,
        artistAffinities,
        preferredEnergy: audioProfile.avgEnergy,
        preferredValence: audioProfile.avgValence,
        preferredTempo: audioProfile.avgTempo,
        avoidancePatterns: this.detectAvoidancePatterns(playlists)
      };
    }
    
    // Fallback: Use genre preferences
    return this.getDefaultDNA(context);
  }
  
  private async analyzePlaylist(playlistId: string) {
    const tracks = await this.getAllPlaylistTracks(playlistId);
    const audioFeatures = await this.getAudioFeatures(
      tracks.map(t => t.track.id)
    );
    
    return {
      tracks,
      audioFeatures,
      stats: this.calculateStats(audioFeatures)
    };
  }
}
```

### Step 3: Creative Generation (Claude Opus)

```typescript
class CreativeGenerationEngine {
  private claude: Anthropic;
  
  async generateCreative(
    context: EnrichedContext, 
    dna: MusicalDNA
  ): Promise<CreativePlaylist> {
    
    const response = await this.claude.messages.create({
      model: 'claude-3-opus-20240229',
      max_tokens: 8000,
      temperature: 0.8,
      
      system: `You are the world's best wedding DJ with perfect emotional intelligence.
        
Your superpowers:
- Understanding emotional journey of weddings
- Creating unexpected but perfect combinations
- Building generational bridges through music
- Respecting cultural nuances deeply
- Crafting moments that become memories

Consider the FULL context and create a playlist that:
1. Tells the couple's story
2. Respects all cultural elements
3. Creates peak emotional moments
4. Flows perfectly through the day
5. Surprises and delights guests

For each song suggestion, provide:
- Specific song title and artist
- Why THIS song at THIS moment
- Emotional impact intended
- How it connects to previous/next song
- Alternative if unavailable`,
      
      messages: [{
        role: 'user',
        content: `Create a magical wedding playlist:
          
Context: ${JSON.stringify(context)}
Musical DNA: ${JSON.stringify(dna)}

Timeline needed:
- Guest Arrival: 30 min (2/5 energy)
- Processional: 5 min (3/5 energy)
- Recessional: 5 min (4/5 energy)  
- Cocktail Hour: 90 min (3/5 energy)
- Dinner: 60 min (2/5 energy)
- First Dance: 5 min (special)
- Parent Dances: 10 min (3/5 energy)
- Party Time: 180 min (5/5 energy)
- Last Dance: 5 min (4/5 energy)

Remember to:
- Include the couple's must-play songs naturally
- Create 3+ "wow" moments
- Balance familiar hits with perfect deep cuts
- Ensure multi-generational appeal`
      }]
    });
    
    return this.parseClaudeResponse(response);
  }
}
```

### Step 4: Database Matching

```typescript
class DatabaseMatchingEngine {
  private vectorDB: Pinecone;
  private songDB: PrismaClient;
  
  async matchToRealSongs(
    creativeSuggestions: CreativePlaylist
  ): Promise<MatchedPlaylist> {
    const matched = [];
    
    for (const suggestion of creativeSuggestions.songs) {
      // Try exact match first
      let song = await this.exactMatch(suggestion);
      
      // If not found, use vector similarity
      if (!song) {
        song = await this.vectorMatch(suggestion);
      }
      
      // If still not found, ask Claude for alternatives
      if (!song) {
        song = await this.findAlternative(suggestion);
      }
      
      if (song) {
        matched.push({
          ...song,
          original_suggestion: suggestion,
          match_confidence: this.calculateConfidence(suggestion, song)
        });
      }
    }
    
    return { songs: matched };
  }
  
  private async vectorMatch(suggestion: Suggestion) {
    // Create embedding from suggestion
    const embedding = await this.getEmbedding(
      `${suggestion.title} ${suggestion.artist} ${suggestion.reason}`
    );
    
    // Search vector database
    const results = await this.vectorDB.query({
      vector: embedding,
      filter: {
        wedding_moments: { $in: [suggestion.moment] },
        energy: { 
          $gte: suggestion.target_energy - 0.2,
          $lte: suggestion.target_energy + 0.2
        },
        explicit: false
      },
      topK: 5,
      includeMetadata: true
    });
    
    // Return best match
    return results.matches[0]?.metadata;
  }
  
  private async findAlternative(suggestion: Suggestion) {
    // Ask Claude for alternatives
    const response = await this.claude.messages.create({
      model: 'claude-3-haiku-20240307', // Fast model
      max_tokens: 500,
      messages: [{
        role: 'user',
        content: `"${suggestion.title}" by ${suggestion.artist} is not available.
          Suggest 3 similar songs that would work for: ${suggestion.reason}
          Same energy: ${suggestion.target_energy}
          Same moment: ${suggestion.moment}`
      }]
    });
    
    const alternatives = this.parseAlternatives(response);
    
    // Try to find alternatives in DB
    for (const alt of alternatives) {
      const match = await this.exactMatch(alt);
      if (match) return match;
    }
    
    return null;
  }
}
```

### Step 5: Flow Optimization (GPT)

```typescript
class FlowOptimizationEngine {
  private openai: OpenAI;
  
  async optimizeFlow(playlist: MatchedPlaylist): Promise<OptimizedPlaylist> {
    const response = await this.openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: [{
        role: 'system',
        content: `You are a master of musical flow and DJ mixing.
          
Analyze and optimize for:
1. BPM transitions (max 10% change between songs)
2. Key compatibility (use Camelot wheel)
3. Energy flow (natural builds and releases)
4. Genre transitions (smooth, not jarring)
5. Emotional arc throughout event`
      }, {
        role: 'user',
        content: `Optimize this playlist's flow:
          ${JSON.stringify(playlist)}
          
Ensure:
- No jarring transitions
- Proper energy management
- Harmonic mixing where possible
- Natural crowd psychology`
      }],
      
      functions: [{
        name: 'reorder_playlist',
        description: 'Reorder songs for better flow',
        parameters: {
          type: 'object',
          properties: {
            optimized_order: {
              type: 'array',
              items: { type: 'string' }
            },
            transitions: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  from: { type: 'string' },
                  to: { type: 'string' },
                  quality: { type: 'string' },
                  mixing_notes: { type: 'string' }
                }
              }
            }
          }
        }
      }]
    });
    
    return this.applyOptimizations(playlist, response);
  }
}
```

### Step 6: Quality Assurance

```typescript
class QualityAssuranceEngine {
  private models: Map<string, AIModel>;
  
  async performQualityCheck(
    playlist: OptimizedPlaylist,
    context: EnrichedContext
  ): Promise<QualityReport> {
    
    // Run parallel quality checks
    const checks = await Promise.all([
      this.checkCulturalAppropriateness(playlist, context),
      this.checkTechnicalQuality(playlist),
      this.checkEmotionalFlow(playlist),
      this.checkContentSafety(playlist),
      this.checkMixability(playlist)
    ]);
    
    // Build consensus
    const consensus = {
      overall_score: this.calculateOverallScore(checks),
      issues: checks.flatMap(c => c.issues),
      warnings: checks.flatMap(c => c.warnings),
      strengths: checks.flatMap(c => c.strengths)
    };
    
    // Auto-fix critical issues
    if (consensus.issues.length > 0) {
      return await this.autoFixIssues(playlist, consensus.issues);
    }
    
    return consensus;
  }
  
  private async checkCulturalAppropriateness(playlist, context) {
    const response = await this.claude.messages.create({
      model: 'claude-3-sonnet-20240229',
      temperature: 0.1,
      messages: [{
        role: 'user',
        content: `Review this playlist for cultural appropriateness:
          Playlist: ${JSON.stringify(playlist)}
          Cultural Context: ${JSON.stringify(context.cultural)}
          
Check for:
- Culturally insensitive songs
- Religious considerations
- Language appropriateness
- Generational sensitivities`
      }]
    });
    
    return this.parseCulturalCheck(response);
  }
}
```

## Part 3: Real-Time Implementation

### API Routes

```typescript
// /app/api/ai/generate-playlist/route.ts
import { AIOrchestrationEngine } from '@/lib/ai-orchestration';
import { SpotifyMusicDatabase } from '@/lib/spotify-database';
import { RateLimiter } from '@/lib/rate-limiter';

const orchestra = new AIOrchestrationEngine();
const database = new SpotifyMusicDatabase();
const limiter = new RateLimiter();

export async function POST(request: Request) {
  try {
    // Rate limiting
    const ip = request.headers.get('x-forwarded-for');
    if (!await limiter.check(ip)) {
      return new Response('Rate limited', { status: 429 });
    }
    
    const input = await request.json();
    
    // Check cache first
    const cached = await getCachedPlaylist(input);
    if (cached && cached.age < 3600000) {
      return NextResponse.json(cached);
    }
    
    // Generate with full AI orchestra
    const playlist = await orchestra.generatePerfectPlaylist(input);
    
    // Ensure all songs exist in our database
    const verified = await database.verifySongs(playlist);
    
    // Cache the result
    await cachePlaylist(input, verified);
    
    // Track analytics
    await trackGeneration({
      input,
      playlist: verified,
      duration: Date.now() - startTime
    });
    
    return NextResponse.json({
      success: true,
      playlist: verified,
      metadata: {
        generated_at: new Date(),
        models_used: ['gemini', 'claude', 'gpt-4', 'spotify'],
        confidence: 0.95
      }
    });
    
  } catch (error) {
    console.error('Generation failed:', error);
    
    // Fallback to simpler approach
    const fallback = await generateSimplePlaylist(input);
    return NextResponse.json({
      success: true,
      playlist: fallback,
      metadata: {
        fallback: true,
        confidence: 0.7
      }
    });
  }
}
```

### Database Seeding Script

```typescript
// /scripts/seed-wedding-database.ts
import { SpotifyDatabaseBuilder } from '@/lib/spotify-database-builder';

async function seedDatabase() {
  const builder = new SpotifyDatabaseBuilder();
  
  console.log('ðŸŽµ Starting database seed...');
  
  // Step 1: Import from Spotify
  const songs = await builder.buildComprehensiveDatabase();
  console.log(`âœ… Imported ${songs.length} songs`);
  
  // Step 2: Build vector embeddings
  console.log('ðŸ§® Building vector embeddings...');
  await builder.buildVectorEmbeddings(songs);
  
  // Step 3: Calculate relationships
  console.log('ðŸ”— Building mixing relationships...');
  await builder.buildMixingRelationships(songs);
  
  // Step 4: Initial AI classification
  console.log('ðŸ¤– Running AI classification...');
  await builder.runInitialClassification(songs);
  
  console.log('âœ… Database seeding complete!');
}

seedDatabase().catch(console.error);
```

## Part 4: Optimization & Scaling

### Caching Strategy

```typescript
class IntelligentCache {
  private redis: Redis;
  private localStorage: LocalStorage;
  
  // Multi-layer caching
  async get(key: string): Promise<any> {
    // L1: Local memory cache (instant)
    if (this.memoryCache.has(key)) {
      return this.memoryCache.get(key);
    }
    
    // L2: Redis cache (fast)
    const redisResult = await this.redis.get(key);
    if (redisResult) {
      this.memoryCache.set(key, redisResult);
      return redisResult;
    }
    
    // L3: Database (slower)
    const dbResult = await this.database.get(key);
    if (dbResult) {
      await this.redis.set(key, dbResult, 'EX', 3600);
      this.memoryCache.set(key, dbResult);
      return dbResult;
    }
    
    return null;
  }
  
  // Smart invalidation
  async invalidate(pattern: string) {
    // Clear all matching keys
    const keys = await this.redis.keys(pattern);
    await Promise.all(keys.map(k => this.redis.del(k)));
    
    // Clear memory cache
    for (const key of this.memoryCache.keys()) {
      if (key.match(pattern)) {
        this.memoryCache.delete(key);
      }
    }
  }
}
```

### Cost Optimization

```typescript
class CostOptimizedPipeline {
  // Use different models based on user tier
  async generate(input: UserInput, tier: UserTier) {
    switch(tier) {
      case 'free':
        // Use cached results + simple matching
        return this.generateFree(input);
        
      case 'premium':
        // Use Claude Haiku + Gemini Flash
        return this.generatePremium(input);
        
      case 'ultimate':
        // Full orchestra with all models
        return this.generateUltimate(input);
    }
  }
  
  // Model selection by task
  private modelSelector = {
    simple_classification: 'claude-3-haiku',      // $0.25/1M tokens
    creative_generation: 'claude-3-sonnet',       // $3/1M tokens
    complex_reasoning: 'claude-3-opus',           // $15/1M tokens
    context_enrichment: 'gemini-2.0-flash',       // Free tier available
    technical_optimization: 'gpt-4-turbo'         // $10/1M tokens
  };
  
  // Batch processing for efficiency
  async batchProcess(requests: Request[]) {
    // Group similar requests
    const grouped = this.groupBySimilarity(requests);
    
    // Process each group with appropriate model
    const results = await Promise.all(
      grouped.map(group => this.processGroup(group))
    );
    
    return results.flat();
  }
}
```

## Part 5: Monitoring & Analytics

### Performance Tracking

```typescript
interface PipelineMetrics {
  // Generation metrics
  total_generations: number;
  average_generation_time: number;
  cache_hit_rate: number;
  fallback_rate: number;
  
  // Quality metrics
  average_confidence_score: number;
  user_satisfaction_rate: number;
  songs_kept_rate: number;
  
  // Technical metrics
  api_latency: {
    spotify: number;
    claude: number;
    gemini: number;
    gpt: number;
  };
  
  // Business metrics
  conversion_rate: number;
  upgrade_rate: number;
  retention_rate: number;
}

class PipelineMonitor {
  async trackGeneration(request: Request, response: Response) {
    const metrics = {
      timestamp: Date.now(),
      user_id: request.user_id,
      input: request.input,
      output: response.playlist,
      duration: response.duration,
      models_used: response.models,
      confidence: response.confidence,
      cache_hit: response.from_cache
    };
    
    // Send to analytics
    await this.analytics.track('playlist_generated', metrics);
    
    // Update dashboards
    await this.updateDashboards(metrics);
    
    // Alert on anomalies
    if (metrics.duration > 10000) {
      await this.alerting.send('Slow generation detected', metrics);
    }
  }
}
```

## Part 6: Future Enhancements

### Planned Improvements

```typescript
interface FutureEnhancements {
  // Real-time collaboration
  collaborative_generation: {
    description: "Multiple users contribute preferences",
    implementation: "WebSocket + CRDT"
  },
  
  // Live DJ mode
  live_dj_assistance: {
    description: "Real-time crowd reading and suggestions",
    implementation: "Mobile app + crowd sentiment analysis"
  },
  
  // Voice interface
  voice_commands: {
    description: "Generate playlists through conversation",
    implementation: "Whisper API + conversational AI"
  },
  
  // Predictive pre-generation
  predictive_caching: {
    description: "Pre-generate likely playlists",
    implementation: "ML prediction + background workers"
  },
  
  // Multi-language support
  global_expansion: {
    description: "Support for 50+ languages and cultures",
    implementation: "Localized models + cultural databases"
  }
}
```

## Conclusion

This AI Music Intelligence Pipeline combines:

1. **Comprehensive Database**: 50,000+ wedding-appropriate songs with full Spotify audio features, DJ mixing data, and AI classifications

2. **Multi-Model AI Orchestra**: Each model contributes its strength:
   - Gemini: Cultural context and knowledge
   - Claude: Creative generation and cultural sensitivity
   - GPT: Technical optimization and flow
   - Spotify: Musical analysis and taste matching

3. **Intelligent Matching**: Vector embeddings ensure AI suggestions map to real, playable songs

4. **Professional Output**: DJ-ready playlists with mixing notes, harmonic compatibility, and smooth transitions

5. **Scalable Architecture**: Efficient caching, cost optimization, and fallback strategies

The result is a system that generates perfect, personalized wedding playlists in seconds - combining AI creativity with professional music curation.

Total implementation time: 2-3 weeks for MVP, 2-3 months for full pipeline.