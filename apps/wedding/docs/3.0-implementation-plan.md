# Uptune 3.0: Implementation Plan

## Overview
Transform Uptune into an AI-powered wedding playlist platform with Spotify integration and intelligent song matching, while maintaining the existing Firebase/Firestore architecture.

## Current State Analysis

### Existing Infrastructure
- **Database**: Firebase Firestore (NoSQL)
- **Auth**: Firebase Auth
- **Storage**: Firebase Storage
- **APIs**: Spotify Web API (partial integration)
- **Static Data**: Pre-populated song catalogs in TypeScript files
- **Frontend**: Next.js 15 with React

### Key Findings
1. No SQL database - everything is in Firestore
2. Extensive static song data already exists
3. Spotify integration partially implemented
4. Firebase Admin SDK already configured
5. Strong typing with TypeScript throughout

## Implementation Phases

## Phase 1: Database Enhancement (Week 1)

### 1.1 Extend Firestore Schema
Create new collections for AI-powered features:

```typescript
// New Firestore Collections
songs_master {
  spotify_id: string
  title: string
  artist: string
  album: string
  
  // Spotify Audio Features
  tempo: number
  energy: number
  danceability: number
  valence: number
  key: number
  mode: number
  
  // Wedding Classification
  wedding_moments: string[]
  wedding_score: number
  play_count: number
  
  // AI Metadata
  embeddings: number[]
  last_analyzed: timestamp
}

ai_playlists {
  user_id: string
  wedding_id: string
  input_context: object
  generated_playlist: object
  models_used: string[]
  confidence: number
  created_at: timestamp
}

user_preferences {
  user_id: string
  spotify_playlists: string[]
  favorite_genres: string[]
  audio_dna: object
  last_updated: timestamp
}
```

### 1.2 Migration Strategy
- Keep existing collections intact
- Add new collections alongside
- Gradual migration of static data to Firestore
- Maintain backwards compatibility

## Phase 2: Spotify Integration (Week 1)

### 2.1 Full Spotify API Setup
- Complete OAuth flow implementation
- Bulk import capabilities
- Audio features fetching
- Playlist creation/export

### 2.2 Data Import Pipeline
- Script to import wedding playlists
- Harvest audio features
- Store in Firestore with rate limiting
- Build initial song database

## Phase 3: AI Integration (Week 2)

### 3.1 Claude/Anthropic Setup
- API key configuration
- Service class implementation
- Prompt templates for playlist generation
- Error handling and fallbacks

### 3.2 Multi-Model Orchestra
- Context enrichment (Gemini)
- Creative generation (Claude)
- Musical analysis (Spotify)
- Database matching logic

### 3.3 Vector Search
- Implement embeddings generation
- Use Firestore vector search (or Pinecone)
- Similarity matching for songs
- Fallback strategies

## Phase 4: API Development (Week 2)

### 4.1 Core API Routes
```
POST /api/ai/generate-playlist
POST /api/spotify/import-songs  
GET  /api/songs/search
POST /api/playlists/save
GET  /api/playlists/[id]
```

### 4.2 Background Jobs
- Spotify data sync
- AI classification queue
- Popularity updates
- Cache warming

## Phase 5: Frontend Integration (Week 3)

### 5.1 Update v3 Page
- Connect to real AI API
- Real-time playlist updates
- Spotify preview player
- Save functionality

### 5.2 Dashboard Updates
- AI playlist history
- Customization interface
- Export to Spotify
- Share functionality

## Phase 6: Optimization (Week 3-4)

### 6.1 Caching Layer
- Implement Firestore caching
- Session storage for drafts
- CDN for static assets
- API response caching

### 6.2 Performance
- Lazy loading
- Code splitting
- Image optimization
- Bundle size reduction

## Technical Architecture

### Data Flow
```
User Input 
  → Frontend (Next.js)
  → API Route
  → AI Service (Claude/Gemini)
  → Spotify Service (Audio Features)
  → Firestore (Song Database)
  → Matching Algorithm
  → Response Cache
  → Frontend Update
```

### Service Architecture
```typescript
// Core Services
class AIOrchestrationService {
  - generatePlaylist()
  - enrichContext()
  - validateOutput()
}

class SpotifyService {
  - importPlaylists()
  - getAudioFeatures()
  - searchTracks()
  - createPlaylist()
}

class FirestoreService {
  - saveSongs()
  - searchSongs()
  - updateAnalytics()
}

class MatchingService {
  - exactMatch()
  - fuzzyMatch()
  - vectorSearch()
}
```

## Database Migration Plan

### Step 1: Create New Collections
```javascript
// Firestore collections to create
- songs_master (Spotify enriched songs)
- ai_playlists (Generated playlists)
- user_preferences (Musical DNA)
- song_embeddings (Vector search)
```

### Step 2: Import Existing Data
```javascript
// Migrate static TypeScript data to Firestore
- Import from spotify-wedding-songs.ts
- Import from genre-songs/*
- Import from essential-wedding-songs.ts
```

### Step 3: Enrich with Spotify
```javascript
// Add Spotify audio features
- Match existing songs to Spotify IDs
- Fetch audio features
- Calculate wedding moments
- Store in songs_master
```

## API Implementation Details

### Generate Playlist Endpoint
```typescript
// /app/api/ai/generate-playlist/route.ts
export async function POST(request: Request) {
  // 1. Parse input
  const input = await request.json();
  
  // 2. Check cache
  const cached = await checkCache(input);
  if (cached) return cached;
  
  // 3. Enrich context
  const context = await enrichContext(input);
  
  // 4. Generate with AI
  const aiSuggestions = await generateWithClaude(context);
  
  // 5. Match to real songs
  const playlist = await matchToDatabase(aiSuggestions);
  
  // 6. Save and return
  await saveToFirestore(playlist);
  return NextResponse.json(playlist);
}
```

### Spotify Import Script
```typescript
// /scripts/import-spotify-songs.ts
async function importWeddingSongs() {
  // 1. Search wedding playlists
  const playlists = await searchPlaylists([
    'wedding 2025',
    'first dance',
    'wedding party'
  ]);
  
  // 2. Extract unique tracks
  const tracks = await extractTracks(playlists);
  
  // 3. Get audio features
  const enriched = await getAudioFeatures(tracks);
  
  // 4. Classify for weddings
  const classified = await classifyForWeddings(enriched);
  
  // 5. Save to Firestore
  await saveToFirestore(classified);
}
```

## Environment Variables

### Required New Variables
```bash
# AI Services
ANTHROPIC_API_KEY=
OPENAI_API_KEY=
GOOGLE_AI_API_KEY=

# Spotify (Complete)
SPOTIFY_CLIENT_ID=
SPOTIFY_CLIENT_SECRET=
SPOTIFY_REDIRECT_URI=

# Vector Search (Optional)
PINECONE_API_KEY=
PINECONE_ENVIRONMENT=

# Caching (Optional)
UPSTASH_REDIS_URL=
UPSTASH_REDIS_TOKEN=
```

## Testing Strategy

### Unit Tests
- AI service mocking
- Database operations
- API endpoints
- Matching algorithms

### Integration Tests
- Spotify API integration
- AI model responses
- End-to-end playlist generation
- Cache behavior

### Performance Tests
- Load testing API endpoints
- Database query optimization
- Caching effectiveness
- Response times

## Rollout Strategy

### Week 1: Foundation
- Set up new Firestore collections
- Implement Spotify integration
- Begin data import

### Week 2: AI Integration
- Claude/Anthropic setup
- Basic playlist generation
- Database matching

### Week 3: Frontend
- Update v3 page
- Connect to real API
- Testing and refinement

### Week 4: Optimization
- Caching implementation
- Performance tuning
- Production deployment

## Success Metrics

### Technical Metrics
- API response time < 3s
- Playlist generation < 5s
- Cache hit rate > 60%
- Error rate < 1%

### Business Metrics
- Conversion rate improvement
- User engagement increase
- Playlist satisfaction score
- Spotify export rate

## Risk Mitigation

### Technical Risks
1. **Firestore Limits**: Use batch operations and caching
2. **API Rate Limits**: Implement queuing and retries
3. **AI Costs**: Cache aggressively, use tiered models
4. **Spotify Availability**: Fallback to static data

### Business Risks
1. **User Confusion**: Gradual rollout with A/B testing
2. **Data Quality**: Manual curation of top songs
3. **Cost Overrun**: Monitor usage, implement limits
4. **Competition**: Fast iteration and unique features

## Next Steps

1. **Immediate Actions**:
   - Set up Spotify app credentials
   - Create new Firestore collections
   - Begin implementing Spotify service

2. **This Week**:
   - Complete Spotify integration
   - Import initial song database
   - Set up AI services

3. **Next Week**:
   - Implement playlist generation
   - Update frontend
   - Begin testing

## Conclusion

This implementation plan leverages the existing Firebase infrastructure while adding powerful AI and Spotify capabilities. By maintaining backwards compatibility and implementing gradually, we minimize risk while delivering significant new value to users.