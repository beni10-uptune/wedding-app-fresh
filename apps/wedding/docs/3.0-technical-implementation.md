# Uptune 3.0: Technical Implementation Guide

## Architecture Overview

### System Design
```
┌─────────────────────────────────────────────┐
│                 Frontend (Next.js)           │
│  ┌─────────────────────────────────────┐    │
│  │     Interactive Playlist Builder     │    │
│  ├─────────────────────────────────────┤    │
│  │  State Management (React Context)    │    │
│  ├─────────────────────────────────────┤    │
│  │   Local Storage Persistence Layer    │    │
│  └─────────────────────────────────────┘    │
└────────────────┬───────────────────────────┘
                 │
                 ↓ API Calls
┌─────────────────────────────────────────────┐
│            Backend Services                  │
│  ┌─────────────────────────────────────┐    │
│  │     Next.js API Routes               │    │
│  ├─────────────────────────────────────┤    │
│  │     AI Recommendation Engine         │    │
│  ├─────────────────────────────────────┤    │
│  │     Spotify Integration Service      │    │
│  ├─────────────────────────────────────┤    │
│  │     Firebase Firestore               │    │
│  └─────────────────────────────────────┘    │
└─────────────────────────────────────────────┘
```

## Core Components

### 1. Interactive Playlist Builder (`/app/v3/page.tsx`)

#### State Architecture
```typescript
interface PlaylistBuilderState {
  // User Inputs
  mustPlaySongs: string[];
  country: string;
  genres: string[];
  weddingType: string;
  customInstructions: string;
  spotifyPlaylists: string[];
  
  // Generated Content
  timeline: WeddingMoment[];
  suggestions: Map<string, Song[]>;
  aiProcessing: boolean;
  
  // User Journey
  interactionCount: number;
  firstInteractionTime: number | null;
  customizationDepth: number;
  sessionId: string;
  
  // UI State
  expandedMoments: Set<string>;
  previewingSong: string | null;
  showConversionModal: boolean;
}

interface WeddingMoment {
  id: string;
  time: string;
  duration: string;
  title: string;
  emoji: string;
  energy: number;
  description: string;
  tip: string;
  songs: Song[];
  expandable?: number;
  customized?: boolean;
}

interface Song {
  id: string;
  title: string;
  artist: string;
  spotifyId?: string;
  previewUrl?: string;
  energy?: number;
  popularity?: number;
  features?: AudioFeatures;
}
```

#### Real-time Update Engine
```typescript
const PlaylistUpdateEngine = {
  // Debounced updates for text inputs
  updateCustomInstructions: debounce(async (instructions: string) => {
    const updates = await processInstructions(instructions);
    applyTimelineUpdates(updates);
  }, 500),
  
  // Immediate updates for selections
  updateGenres: (genres: string[]) => {
    const filteredSongs = filterSongsByGenres(genres);
    updateTimelineSongs(filteredSongs);
  },
  
  // Progressive enhancement
  addMustPlaySong: (song: string) => {
    if (songs.length === 0) {
      updateFirstDance(song);
    } else {
      addToSpecialMoments(song);
    }
  }
};
```

### 2. AI Recommendation Service

#### Architecture
```typescript
// /app/api/ai/recommendations/route.ts
export async function POST(request: Request) {
  const { 
    customInstructions, 
    genres, 
    mustPlaySongs,
    weddingType,
    country 
  } = await request.json();
  
  // Build context for AI
  const context = buildContext({
    instructions: customInstructions,
    preferences: { genres, weddingType, country },
    requirements: mustPlaySongs
  });
  
  // Generate recommendations
  const recommendations = await generateRecommendations(context);
  
  // Apply safety filters
  const filtered = applyContentFilters(recommendations);
  
  // Return structured response
  return NextResponse.json({
    recommendations: filtered,
    confidence: calculateConfidence(filtered),
    metadata: {
      processedAt: Date.now(),
      model: 'claude-3.5-sonnet',
      filters: ['explicit', 'cultural-sensitivity']
    }
  });
}
```

#### Prompt Engineering
```typescript
const SYSTEM_PROMPT = `
You are a wedding music expert creating personalized playlists.

Consider:
1. Cultural sensitivities and traditions
2. Age range of guests (typically 20-80)
3. Energy flow throughout the event
4. Explicit content filtering
5. Regional music preferences

Output format:
{
  "moment_id": {
    "songs": [
      {
        "title": "Song Name",
        "artist": "Artist Name",
        "reason": "Why this fits",
        "energy": 1-5
      }
    ],
    "adjustments": "Explanation of changes"
  }
}
`;

const buildUserPrompt = (context: Context) => `
Wedding Details:
- Type: ${context.weddingType}
- Location: ${context.country}
- Genres: ${context.genres.join(', ')}
- Must Play: ${context.mustPlaySongs.join(', ')}

Special Instructions:
${context.customInstructions}

Generate song recommendations for each moment that respect these preferences.
`;
```

### 3. Spotify Integration Layer

#### Development Mode Implementation
```typescript
// /lib/spotify-dev.ts
export class SpotifyDevService {
  // Parse Spotify URLs without OAuth
  async parsePlaylistUrl(url: string): Promise<PlaylistData> {
    const playlistId = extractPlaylistId(url);
    
    // Use public Spotify Web API (no auth needed for public data)
    const response = await fetch(
      `https://api.spotify.com/v1/playlists/${playlistId}`,
      {
        headers: {
          'Authorization': `Bearer ${await getAppToken()}`
        }
      }
    );
    
    return parsePlaylistResponse(response);
  }
  
  // Get song previews (always available)
  async getSongPreview(spotifyId: string): Promise<string | null> {
    const track = await getTrack(spotifyId);
    return track.preview_url;
  }
  
  // Analyze music taste from URLs
  async analyzeTaste(playlistUrls: string[]): Promise<TasteProfile> {
    const playlists = await Promise.all(
      playlistUrls.map(url => this.parsePlaylistUrl(url))
    );
    
    return {
      topGenres: extractTopGenres(playlists),
      energyProfile: calculateEnergyProfile(playlists),
      topArtists: extractTopArtists(playlists),
      audioFeatures: aggregateAudioFeatures(playlists)
    };
  }
}
```

#### Production Mode Implementation
```typescript
// /lib/spotify-prod.ts
export class SpotifyProdService extends SpotifyDevService {
  // Full OAuth implementation
  async authenticateUser(): Promise<SpotifyAuth> {
    // Redirect to Spotify OAuth
    const authUrl = buildAuthUrl({
      clientId: process.env.SPOTIFY_CLIENT_ID,
      redirectUri: `${process.env.NEXT_PUBLIC_URL}/api/spotify/callback`,
      scopes: ['playlist-modify-private', 'playlist-modify-public']
    });
    
    return { authUrl };
  }
  
  // Export playlist to Spotify
  async exportPlaylist(
    userId: string,
    playlist: Playlist,
    token: string
  ): Promise<SpotifyPlaylist> {
    // Create playlist
    const created = await createPlaylist(userId, {
      name: `${playlist.coupleName} Wedding`,
      description: 'Created with Uptune',
      public: false
    }, token);
    
    // Add tracks
    await addTracksToPlaylist(
      created.id,
      playlist.songs.map(s => s.spotifyId),
      token
    );
    
    return created;
  }
}
```

### 4. State Persistence Layer

#### Local Storage Manager
```typescript
// /lib/storage.ts
export class PlaylistStorage {
  private readonly STORAGE_KEY = 'uptune_playlist_v3';
  private readonly SESSION_KEY = 'uptune_session';
  
  save(state: PlaylistBuilderState): void {
    try {
      const serialized = JSON.stringify({
        ...state,
        savedAt: Date.now(),
        version: '3.0'
      });
      
      localStorage.setItem(this.STORAGE_KEY, serialized);
      
      // Track in analytics
      analytics.track('playlist_saved_locally', {
        customizationDepth: state.customizationDepth,
        hasMustPlaySongs: state.mustPlaySongs.length > 0,
        hasCustomInstructions: !!state.customInstructions
      });
    } catch (error) {
      console.error('Failed to save playlist:', error);
      // Fallback to session storage
      sessionStorage.setItem(this.STORAGE_KEY, serialized);
    }
  }
  
  load(): PlaylistBuilderState | null {
    try {
      const stored = localStorage.getItem(this.STORAGE_KEY);
      if (!stored) return null;
      
      const parsed = JSON.parse(stored);
      
      // Version migration if needed
      if (parsed.version !== '3.0') {
        return this.migrate(parsed);
      }
      
      return parsed;
    } catch {
      return null;
    }
  }
  
  clear(): void {
    localStorage.removeItem(this.STORAGE_KEY);
    sessionStorage.removeItem(this.STORAGE_KEY);
  }
}
```

### 5. Analytics & Tracking

#### Event Tracking System
```typescript
// /lib/analytics.ts
export const PlaylistAnalytics = {
  // Track user journey
  trackInteraction(event: string, properties?: any) {
    // Google Analytics 4
    gtag('event', event, {
      event_category: 'playlist_builder',
      event_label: properties?.label,
      value: properties?.value,
      ...properties
    });
    
    // Mixpanel for detailed analysis
    if (typeof mixpanel !== 'undefined') {
      mixpanel.track(event, {
        ...properties,
        session_id: getSessionId(),
        timestamp: Date.now()
      });
    }
  },
  
  // Conversion funnel
  trackFunnelStep(step: string, metadata?: any) {
    this.trackInteraction(`funnel_${step}`, {
      step_name: step,
      ...metadata
    });
  },
  
  // A/B Testing
  getVariant(experiment: string): string {
    const variants = {
      'first_input': ['must_play', 'location', 'genres'],
      'cta_text': ['save_playlist', 'customize_more', 'continue_free'],
      'modal_style': ['minimal', 'detailed', 'social_proof']
    };
    
    // Use consistent hashing for user
    const userId = getUserId();
    const hash = hashCode(userId + experiment);
    const variantIndex = Math.abs(hash) % variants[experiment].length;
    
    return variants[experiment][variantIndex];
  }
};
```

## Performance Optimizations

### 1. Code Splitting
```typescript
// Dynamic imports for heavy components
const SpotifyPlayer = dynamic(
  () => import('@/components/SpotifyPlayer'),
  { 
    loading: () => <PlayerSkeleton />,
    ssr: false 
  }
);

const AICustomizer = dynamic(
  () => import('@/components/AICustomizer'),
  { 
    loading: () => <CustomizerSkeleton />,
    ssr: false 
  }
);
```

### 2. Data Fetching Strategy
```typescript
// Parallel data fetching
export async function getInitialData() {
  const [
    defaultSongs,
    userLocation,
    popularGenres
  ] = await Promise.all([
    fetchDefaultSongs(),
    detectUserLocation(),
    fetchPopularGenres()
  ]);
  
  return {
    songs: defaultSongs,
    location: userLocation,
    genres: popularGenres
  };
}

// Optimistic updates
const updatePlaylist = async (changes: Changes) => {
  // Update UI immediately
  setTimeline(prev => applyChanges(prev, changes));
  
  // Sync in background
  try {
    await syncChanges(changes);
  } catch (error) {
    // Rollback on failure
    setTimeline(prev => rollbackChanges(prev, changes));
    showError('Failed to save changes');
  }
};
```

### 3. Rendering Optimizations
```typescript
// Virtualization for long lists
import { FixedSizeList } from 'react-window';

const SongList = ({ songs }: { songs: Song[] }) => (
  <FixedSizeList
    height={600}
    itemCount={songs.length}
    itemSize={80}
    width="100%"
  >
    {({ index, style }) => (
      <SongItem
        key={songs[index].id}
        song={songs[index]}
        style={style}
      />
    )}
  </FixedSizeList>
);

// Memoization for expensive computations
const PlaylistStats = memo(({ timeline }: { timeline: WeddingMoment[] }) => {
  const stats = useMemo(() => calculateStats(timeline), [timeline]);
  
  return (
    <div className="stats">
      <div>{stats.totalSongs} songs</div>
      <div>{stats.duration} hours</div>
      <div>{stats.energy} avg energy</div>
    </div>
  );
});
```

### 4. API Response Caching
```typescript
// Edge caching strategy
export const config = {
  runtime: 'edge',
};

export async function GET(request: Request) {
  const cacheKey = new URL(request.url).searchParams.toString();
  
  // Check cache
  const cached = await cache.match(cacheKey);
  if (cached && !isStale(cached)) {
    return cached;
  }
  
  // Generate fresh response
  const response = await generateResponse(request);
  
  // Cache with appropriate headers
  const cacheableResponse = new Response(response.body, {
    headers: {
      ...response.headers,
      'Cache-Control': 'public, max-age=3600, stale-while-revalidate=86400',
      'CDN-Cache-Control': 'max-age=86400'
    }
  });
  
  await cache.put(cacheKey, cacheableResponse);
  return response;
}
```

## Database Schema

### Firestore Collections
```typescript
// weddings collection
interface Wedding {
  id: string;
  userId: string;
  slug: string;
  coupleName: string;
  weddingDate: Timestamp;
  timeline: WeddingMoment[];
  customization: {
    mustPlaySongs: string[];
    genres: string[];
    customInstructions: string;
    country: string;
    weddingType: string;
  };
  metadata: {
    createdAt: Timestamp;
    updatedAt: Timestamp;
    lastAccessed: Timestamp;
    version: string;
  };
  sharing: {
    publicUrl: string;
    guestSubmissions: boolean;
    djAccess: boolean;
  };
}

// user_analytics collection
interface UserAnalytics {
  userId: string;
  sessions: Session[];
  conversions: Conversion[];
  experiments: ExperimentAssignment[];
  lifetime: {
    firstSeen: Timestamp;
    totalSessions: number;
    totalCustomizations: number;
    converted: boolean;
    plan: string;
  };
}

// playlist_templates collection
interface PlaylistTemplate {
  id: string;
  name: string;
  category: string;
  timeline: WeddingMoment[];
  popularity: number;
  tags: string[];
  regions: string[];
}
```

## Security Considerations

### 1. Input Validation
```typescript
// Sanitize user inputs
const sanitizeInstructions = (input: string): string => {
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: [],
    ALLOWED_ATTR: []
  }).slice(0, 500); // Limit length
};

// Validate Spotify URLs
const validateSpotifyUrl = (url: string): boolean => {
  const pattern = /^https:\/\/open\.spotify\.com\/(playlist|track)\/[a-zA-Z0-9]+/;
  return pattern.test(url);
};
```

### 2. Rate Limiting
```typescript
// API route protection
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, '10 s'),
});

export async function POST(request: Request) {
  const ip = request.headers.get('x-forwarded-for') ?? 'unknown';
  const { success } = await ratelimit.limit(ip);
  
  if (!success) {
    return new Response('Too many requests', { status: 429 });
  }
  
  // Process request
}
```

### 3. Content Filtering
```typescript
// Filter inappropriate content
const contentFilter = {
  explicit: ['explicit', 'profanity', 'adult'],
  violence: ['violent', 'aggressive'],
  substance: ['drugs', 'alcohol'],
  
  isAppropriate(song: Song): boolean {
    const combined = `${song.title} ${song.artist}`.toLowerCase();
    
    for (const category of Object.values(this)) {
      if (Array.isArray(category)) {
        for (const term of category) {
          if (combined.includes(term)) {
            return false;
          }
        }
      }
    }
    
    return true;
  }
};
```

## Testing Strategy

### 1. Unit Tests
```typescript
// Component testing
describe('PlaylistBuilder', () => {
  it('should update timeline when genres change', () => {
    const { getByRole, getAllByTestId } = render(<PlaylistBuilder />);
    
    fireEvent.click(getByRole('button', { name: 'Rock' }));
    
    const songs = getAllByTestId('song-item');
    expect(songs.some(s => s.textContent?.includes('rock'))).toBe(true);
  });
  
  it('should persist state to localStorage', () => {
    const { getByPlaceholderText } = render(<PlaylistBuilder />);
    
    fireEvent.change(
      getByPlaceholderText('Enter your must-play songs'),
      { target: { value: 'Perfect - Ed Sheeran' } }
    );
    
    const stored = localStorage.getItem('uptune_playlist_v3');
    expect(JSON.parse(stored!).mustPlaySongs).toContain('Perfect - Ed Sheeran');
  });
});
```

### 2. Integration Tests
```typescript
// API testing
describe('AI Recommendations API', () => {
  it('should return culturally appropriate suggestions', async () => {
    const response = await fetch('/api/ai/recommendations', {
      method: 'POST',
      body: JSON.stringify({
        customInstructions: 'Indian and Southern US families',
        country: 'USA'
      })
    });
    
    const data = await response.json();
    expect(data.recommendations).toBeDefined();
    expect(data.confidence).toBeGreaterThan(0.7);
  });
});
```

### 3. E2E Tests
```typescript
// Playwright tests
test('complete onboarding flow', async ({ page }) => {
  await page.goto('/v3');
  
  // Add must-play song
  await page.fill('[placeholder*="must-play"]', 'Perfect');
  await expect(page.locator('.timeline')).toContainText('Perfect');
  
  // Select genres
  await page.click('text=Country');
  await page.click('text=Pop');
  
  // Add custom instructions
  await page.fill('[placeholder*="special requirements"]', 'No explicit lyrics');
  
  // Attempt to save
  await page.click('text=Customize Every Detail');
  
  // Should show conversion modal
  await expect(page.locator('.modal')).toBeVisible();
  await expect(page.locator('.modal')).toContainText('Save Your Perfect Playlist');
});
```

## Deployment Configuration

### Environment Variables
```bash
# .env.production
NEXT_PUBLIC_URL=https://weddings.uptune.xyz
NEXT_PUBLIC_GA_ID=G-XXXXXXXXXX
NEXT_PUBLIC_MIXPANEL_TOKEN=xxxxxxxxxxxx

# API Keys (server-side only)
OPENAI_API_KEY=sk-xxxxxxxxxxxx
SPOTIFY_CLIENT_ID=xxxxxxxxxxxx
SPOTIFY_CLIENT_SECRET=xxxxxxxxxxxx
FIREBASE_PROJECT_ID=wedding-app-426623
FIREBASE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n..."
FIREBASE_CLIENT_EMAIL=firebase-adminsdk@wedding-app.iam.gserviceaccount.com

# Feature Flags
ENABLE_AI_CUSTOMIZATION=true
ENABLE_SPOTIFY_OAUTH=false
ENABLE_GUEST_SUBMISSIONS=true

# Rate Limiting
UPSTASH_REDIS_REST_URL=https://xxxxx.upstash.io
UPSTASH_REDIS_REST_TOKEN=xxxxxxxxxxxx
```

### Vercel Configuration
```json
{
  "functions": {
    "app/api/ai/recommendations/route.ts": {
      "maxDuration": 30,
      "memory": 1024
    },
    "app/api/spotify/*/route.ts": {
      "maxDuration": 10,
      "memory": 512
    }
  },
  "crons": [
    {
      "path": "/api/cron/cleanup",
      "schedule": "0 2 * * *"
    }
  ]
}
```

## Monitoring & Observability

### 1. Error Tracking
```typescript
// Sentry integration
Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 0.1,
  integrations: [
    new BrowserTracing(),
    new Replay()
  ]
});

// Custom error boundary
export class PlaylistErrorBoundary extends React.Component {
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    Sentry.captureException(error, {
      contexts: {
        react: errorInfo,
        playlist: {
          customizationDepth: this.props.customizationDepth,
          hasAccount: this.props.hasAccount
        }
      }
    });
  }
}
```

### 2. Performance Monitoring
```typescript
// Web Vitals tracking
export function reportWebVitals(metric: NextWebVitalsMetric) {
  const { id, name, label, value } = metric;
  
  // Send to Google Analytics
  gtag('event', name, {
    event_category: 'Web Vitals',
    event_label: id,
    value: Math.round(name === 'CLS' ? value * 1000 : value),
    non_interaction: true,
  });
  
  // Send to custom monitoring
  if (name === 'FCP' && value > 2000) {
    logSlowMetric('slow_fcp', { value, page: window.location.pathname });
  }
}
```

## Rollout Strategy

### Phase 1: Soft Launch (Week 1)
- 10% traffic split to v3
- Monitor conversion metrics
- Gather user feedback
- Fix critical issues

### Phase 2: Gradual Rollout (Week 2-3)
- Increase to 50% traffic
- A/B test key variations
- Optimize based on data
- Prepare support docs

### Phase 3: Full Launch (Week 4)
- 100% traffic to v3
- Deprecate old version
- Launch marketing campaign
- Monitor closely for issues

## Success Metrics

### Technical Metrics
- Page Load Time: < 2s (p75)
- Time to Interactive: < 3s (p75)
- API Response Time: < 500ms (p95)
- Error Rate: < 0.1%
- Uptime: > 99.9%

### Business Metrics
- Conversion Rate: 3-4% (visitor → signup)
- Activation Rate: 60% (signup → customization)
- Retention: 40% (7-day)
- NPS Score: > 70

## Conclusion

The 3.0 technical implementation focuses on creating a performant, scalable, and delightful user experience. By combining real-time updates, intelligent caching, and progressive enhancement, we deliver immediate value while maintaining technical excellence.

The modular architecture ensures easy maintenance and future expansion, while comprehensive monitoring provides insights for continuous improvement.